# Lab 2 - Game states, forward models & AI agents
## Some basic notes
### Tournament vs. game
A game is a single run of a game, whereas a tournament includes repetitions of a single game with multiple matchups (between players). A tournament is created simply by specifying the number of matchups are more than 1 (we shall see where to indicate the number of matchups later). When talking about tournaments here, we are speaking specifically about "Round Robin" tournaments, wherein a single game and matchup is repeated sequentially.

### Implementation context
All the implementation details (files to configure, classes to implement, functions to use, etc.) are given in the context of the TAG framework, which is implied. Also, we shall be working on Intellij IDEA as our IDE, but whenever implementational or operational details or steps are given with respect to this IDE, it shall be made explicit. The more general form of the implementational or operational details or steps will also be mentioned.

### Instantiation
Instantiation here generally refers to (unless mentioned otherwise) the instantiation of classes, i.e. the creation of an object for a given class.

## PRELIMINARY CONCEPTS:<br>Instantiating agents, running tournaments & gathering data
### Issues with the previous way of running games
In the last session, we saw the use of the "Game" class to run the desired game with the GUI. Here, we faced two issues:

1. We had to edit the arguments in the source code to get the desired changes (ex. game to play, number of players, etc.)
2. We could not obtain more detailed data about the performance of agents
3. We could not run the same game repeatedly with different matchups to get more performance data

#### Solving issue 1
The first issue is through the use of JSON configurations, wherein we apply the configurations (specifically, what arguments to use) for a piece of code to run by (1) detailing them in a JSON file and (2) applying these configurations. This is possible because the TAG framework enables the use of JSON files to configure executables files (ex. source codes). The way we apply these configurations in the Intellij IDEA is through the "Edit Configurations" functionality under the "Run" option in the taskbar.

**More on the "Edit Configurations" functionality**:<br>
In this functionality, we can (via a GUI, i.e. a popup window) add and edit configurations we want to apply to any desired file (ex. the source code) in the project directory. Note that we can specify our file under the "Build and run" heading (we can browse the desired file in the given input box). Importantly, we want to add (if not available already) a configuration of type "Application"; this kind of configuration handles the arguments of executable code, i.e. applications. We can give any name for our application. To specify the configuration (JSON) file, we provide the following argument:

`config=<path of JSON file>`

Of course, the path is given relative to our working directory, which is in our case our project directory. An example for this argument:

`config=json/experiments/rungames0.json`

#### Solving issue 2
The second issue is easily solved by using the `evaluation.RunGames` class (instead of the `Game` class) found in the source file "src/main/java/evaluation/RunGames" (relative to the project directory of course). We can specify this in our configuration (in the "Edit Configurations" window) under the "Build and run" heading. The `RunGames` class helps us do two two things:

- Run N number of Round-Robin repetitions of a game between different agents
- Gather & present data on the played games for
  - Each game in the tournament
  - Each agent in the tournament

### More on the application configuration JSON files
_The extensive details are given in this lab session's associated PDF file. Here, we shall look at certain key points not mentioned._

#### "listener" field
A listener in Java is a subroutine (_i.e. a set of instructions to perform a frequent task in an application_) that handles specified events generated by main running application. We need a listener to wait for the game or tournament (i.e. a series of games) to end and handle the generated output data (in our case, we handle it by saving it in a specified file). For our current purpose, the listener defined in "json/listeners/basiclistener.json" is sufficient, so this is the path we shall provide in the "listener" field.

**IMPORTANT NOTE**: Without specifying a listener, the application will be unable to trigger the storing of the generated output. In such cases, the output will be given in the console itself. If the listener is provided, no output will appear on the console, only in the specified file.

#### "mode" field & "matchups" field
The "matchups" field specifies the number of games to be played in a single execution of the application. The "mode" field specifies how the matchups are made; the "exhaustive" option means each player will play against every other player, the "random" option means players will be assigned to each other randomly.

#### "destDir" field
This is short for "destination directory". This specifies the directory within which any outputs must be stored.

#### "output" field
This specifies the particular file within the destination directory wherein we want to store our outputs. We can use any type of plaintext file (ex. ".txt"), but if we use the extension ".log", we will get our logs (i.e. output data) stored in a better format (i.e. the IDE will be able to recognize the file type and format the text accordingly).

#### "playerDirectory" field
This field specifies the directory within which we can find the configuration files for the players of the game/tournament we want to run. We shall discuss these player configuration files later.

### Player configuration files
A "player" here is what we call an "agent". Here, we are specifically dealing with AI agents. Note that we are not creating new agents yet, we are only instantiating existing agents (specifically instantiating the player classes that define them). Player configuration files are JSON files that have specify:

- The player class to implement<br>(_player class source files found in "src/main/java/players"_)
- The heuristic (for the player) to use

**SIDE NOTE**: The details about creating these files is given in the PDF document associated to this lab session. However, there is one point from this document I want to address. When creating the the one-step-look-ahead (OSLA) player, the "heuristics" field included all sorts of sub-fields (apart from the "class" field that refers to the class that implements the heuristic). However, these sub-fields were misplaced here; these do not apply to the "ScoreHeuristic" we are using. Rather, these apply to the "ColdExpressHeuristic" mentioned elsewhere. So, we can omit these sub-fields when using the "ScoreHeuristic".

## CONCEPT 1: Game state
A game state is the full context required, i.e. the set of all information required to (fully) describe the current game's running processes & environment in the current time. The game state helps us judge the current situation of the game and help see potential outcomes for decisions taken from the current situation (_in the context of AI agents, a game state's deep copy made for a particular agent encapsulates what the agent can observe in the game; a game state's deep copy is discussed further below_). By its nature, the game state does not implement any game functions or features; after all, it is an container class (_i.e. it contains information_) and any functions it uses are only to access the contained information (_i.e. only uses accessor functions_) in a given way and to a given extent.

The game state is modified by player actions and environmental changes (both regulated by the forward model, i.e. the game's rules applied (up to some potential game state) from the given game state). _Note that the player actions, environment changes and the forward model is where the game's functionalities are actually implemented_.

In TAG, every game state class extends from (i.e. inherits and implements) the abstract class `core.AbstractGameState` (i.e. the `AbstractGameState` class within the "core" directory contained in "src/main/java"). This abstract class provides a lot of basic functionality and templates for further functionalities (_i.e. declares (but does not define) the functions that are to be implemented (i.e. defined) by any non-abstract subclass_).

### Copy method
The most important method (i.e. function) applicable to a game state is "copy", which does the following:

- Deep copies the game state [^1]; this enables players to make simulations using these deep copies without modifying the original game state object
- In case of partial information games, hides the information hidden to a given player when making a deep copy for it<br>**SIDE NOTE**: _If the argument_ `-1` _is given, no information is hidden_

[^1] "Deep copy" means creating a new separate object with identical values rather than simply creating a new identifier for the same object (shallow copy)_.

## CONCEPT 2: Forward model
A forward model (FM) is an object that encapsulates (computationally) the relationship between any given game state and the potential game states that can be derived from it through valid action(s) (_valid means possible in the given state_). Hence, an FM also includes a representation of the game's rules. Every player can obtain (on demand) a separate instance of the FM (i.e. each gets a separate FM object for the same game), enabling the player to:

- See the potential consequences of its actions (i.e. simulate a game from a given game state)
- Make valid actions (i.e. according to the game's rules)

In TAG, every FM class extends from (i.e. inherits and implements) the abstract class `core.AbstractForwardModel` (i.e. the `AbstractForwardModel` class within the "core" directory contained in "src/main/java"). This abstract class provides the functionalities and templates for new FMs, effectively providing the functionalities and templates for new games. This abstract class's functionalities are embodied in separate functions (which must be implemented by any class that extends this abstract class):

1. `_setup` (_to set up the initial game state_)
2. `_next` (_to progress the game state based on the player's decision(s)_)
3. `_computeAvailableActions` (_to reveal the valid actions available to the next player_)

## CONCEPT 3: AI agents
In TAG, every agent has to extend from (i.e. inherit and implement) the abstract class `core.AbstractPlayer` (i.e. the `AbstractPlayer` class within the "core" directory contained in "src/main/java") and implement the following methods of this abstract class:

- `_getActions`
	- Accepts two parameters as arguments:
		- _**observation**_: a game state object (_of a concrete class that inherits & implements the abstract class_ `core.AbstractGameState`) that is particular to the agent's its perspective, i.e. encapsulates everything the agent can observe (_including private & common elements_)
		- _**list of available actions**_: an array of action objects (_of one or more defined action classes which inherit & implement the abstract class _ `core.AbstractAction`) based on the available actions at a given game state computer by the forward model (_as implemented by the programmer_)
- `copy`
	- Accepts no parameters (i.e. has no arguments)
	- Returns a copy of the agent (may by a shallow or deep copy, depending on the implementation)

**NOTE**: When a method's definition or declaration specifies the object of a certain class (including an abstract class) as a certain parameter (i.e. argument), this method would also accept any object from this class's subclass for this parameter; after all, an object of subclass B of parent class A is technically an indirect instantiation of the parent class A.

Furthermore, there are certain methods of `core.AbstractPlayer` that can be overridden [^2] by subclasses that implement this abstract class; these are listed, and their core functionalities and possible overrides/changes to their functionalities are explained in the PDF document for this lab session (_lab2-guide.pdf_). To list these methods:

- `initializePlayer`
- `finalizePlayer`
- `toString`
- `registerUpdatedObservations`
- `setForwardModel`
- `getDecisionStats`

[^2]_Overriding a parent class's method refers to a redefinition (by a subclass that inherits the parent class) of a certain function defined in the parent class_.

**NOTE**: You can see some AI agents that have already been implemented in the TAG framework; their code can be found in the directory "src/main/java/players".

### Defining heuristics
You can add a heuristic function to your AI agent by defining and instantiating a class that implements the interface `core.interfaces.IStateHeuristic` (i.e. the `IStateHeuristic` interface found in the "interfaces directory in "src/main/java/core"). Heuristic classes for some games have already been implemented in TAG, such as the heuristic `TicTacToeHeuristic` defined in the directory "src/main/java/games/tictactoe".
