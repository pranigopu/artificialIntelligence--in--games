# Lab 2 - Game states, forward models & AI agents
## Some basic ideas
### Tournament vs. game
A game is a single run of a game, whereas a tournament includes repetitions of a single game with multiple matchups (between players). A tournament is created simply by specifying the number of matchups are more than 1 (we shall see where to indicate the number of matchups later). When talking about tournaments here, we are speaking specifically about "Round Robin" tournaments, wherein a single game and matchup is repeated sequentially.

## Instantiating agents, running tournaments & gathering data
### Issues with the previous way of running games
In the last session, we saw the use of the "Game" class to run the desired game with the GUI. Here, we faced two issues:

1. We had to edit the arguments in the source code to get the desired changes (ex. game to play, number of players, etc.)
2. We could not obtain more detailed data about the performance of agents
3. We could not run the same game repeatedly with different matchups to get more performance data

#### Solving issue 1
The first issue is through the use of JSON configurations, wherein we apply the configurations (specifically, what arguments to use) for a piece of code to run by (1) detailing them in a JSON file and (2) applying these configurations. This is possible because the TAG framework enables the use of JSON files to configure executables files (ex. source codes). The way we apply these configurations in the Intellij IDEA is through the "Edit Configurations" functionality under the "Run" option in the taskbar.

**More on the "Edit Configurations" functionality**:<br>
In this functionality, we can (via a GUI, i.e. a popup window) add and edit configurations we want to apply to any desired file (ex. the source code) in the project directory. Note that we can specify our file under the "Build and run" heading (we can browse the desired file in the given input box). Importantly, we want to add (if not available already) a configuration of type "Application"; this kind of configuration handles the arguments of executable code, i.e. applications. We can give any name for our application. To specify the configuration (JSON) file, we provide the following argument:

`config=<path of JSON file>`

Of course, the path is given relative to our working directory, which is in our case our project directory. An example for this argument:

`config=json/experiments/rungames0.json`

#### Solving issue 2
The second issue is easily solved by using the `evaluation.RunGames` class (instead of the `Game` class) found in the source file "src/main/java/evaluation/RunGames" (relative to the project directory of course). We can specify this in our configuration (in the "Edit Configurations" window) under the "Build and run" heading. The `RunGames` class helps us do two two things:

- Run N number of Round-Robin repetitions of a game between different agents
- Gather & present data on the played games for
  - Each game in the tournament
  - Each agent in the tournament

### More on the application configuration JSON files
_The extensive details are given in this lab session's associated PDF file. Here, we shall look at certain key points not mentioned._

#### "listener" field
A listener in Java is a subroutine (_i.e. a set of instructions to perform a frequent task in an application_) that handles specified events generated by main running application. We need a listener to wait for the game or tournament (i.e. a series of games) to end and handle the generated output data (in our case, we handle it by saving it in a specified file). For our current purpose, the listener defined in "json/listeners/basiclistener.json" is sufficient, so this is the path we shall provide in the "listener" field.

**IMPORTANT NOTE**: Without specifying a listener, the application will be unable to trigger the storing of the generated output. In such cases, the output will be given in the console itself. If the listener is provided, no output will appear on the console, only in the specified file.

#### "mode" field & "matchups" field
The "matchups" field specifies the number of games to be played in a single execution of the application. The "mode" field specifies how the matchups are made; the "exhaustive" option means each player will play against every other player, the "random" option means players will be assigned to each other randomly.

#### "destDir" field
This is short for "destination directory". This specifies the directory within which any outputs must be stored.

#### "output" field
This specifies the particular file within the destination directory wherein we want to store our outputs. We can use any type of plaintext file (ex. ".txt"), but if we use the extension ".log", we will get our logs (i.e. output data) stored in a better format (i.e. the IDE will be able to recognize the file type and format the text accordingly).

#### "playerDirectory" field
This field specifies the directory within which we can find the configuration files for the players of the game/tournament we want to run. We shall discuss these player configuration files later.

### Player configuration files
A "player" here is what we call an "agent". Here, we are specifically dealing with AI agents. Note that we are not creating new agents yet, we are only instantiating existing agents (specifically instantiating the player classes that define them). Player configuration files are JSON files that have specify:

- The player class to implement<br>(_player class source files found in "src/main/java/players"_)
- The heuristic (for the player) to use

**SIDE NOTE**: The details about creating these files is given in the PDF document associated to this pab session. However, there is one point from this document I want to address. When creating the the one-step-look-ahead (OSLA) player, the "heuristics" field included all sorts of sub-fields (apart from the "class" field that refers to the class that implements the heuristic). However, these sub-fields were misplaced here; these do not apply to the "ScoreHeuristic" we are using. Rather, these apply to the "ColdExpressHeuristic" mentioned elsewhere. So, we can omit these sub-fields when using the "ScoreHeuristic".
